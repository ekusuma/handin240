#!/usr/local/bin/python3
# handin240.py
#
# Main handin script for students to use to hand in their homework files. Needs
# a .cfg file to know how to handle each file (see the usage in README.md for
# details).
#
# Usage:
#   - cd into the directory with all of the necessary files
#   - Run script with the homework number as the argument:
#       ./handin240 hw1
#   - If the student wishes to submit an incomplete homework (i.e. with certain
#     files missing or unable to compile) they may run the script with the -f flag
#
# Bill Nace <wnace@cmu.edu>         - Reportlab PDF generation
# Edric Kusuma <ekusuma@cmu.edu>    - Student file handin

import handin240_utils.utils as utils
from handin240_utils.utils import bcolors as bc

import os
import codecs
import sys
import shutil
import argparse
import glob
from datetime import datetime
import traceback

try:
    import reportlab
except:
    print("ERROR:")
    print("Please read the directions on the wiki for setting up handin240")
    exit(0)

import re
import json

from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from reportlab.pdfgen import canvas
from reportlab.lib.units import inch
from reportlab.lib import colors
import reportlab.rl_config

try:
    from pygments import highlight
    from pygments.formatter import Formatter
    from pygments.lexers import get_lexer_for_filename, TextLexer
except:
    print("ERROR:")
    print("Please run init_handin240 to install updated packages")
    exit(0)


from contextlib import contextmanager

# Initialize config file
########################
scriptPath  = os.path.dirname(os.path.realpath(__file__))
ENV         = utils.get_env(scriptPath + '/config.ini')

HANDIN_DIR  = ENV['handin_dir']
REFFILE_DIR = ENV['ref_dir']
CFG_DIR     = ENV['cfg_dir']
FONT_DIR    = ENV['font_dir']

# List of file types that should not be printed by reportlab
NO_PRINT = [
    ".png",
    ".jpg",
    ".jpeg"
]

################################################################################
#                           Code for the handin script                         #
################################################################################

def getArgs():
    """Uses argparse to get script options and args from command line.
    Raises an error (and exits) if no arg for hwNum is given.

    Args:
        Nothing

    Returns:
        (obj): An argparse object whose attributes correspond to the options
            defined via add_option().

    """
    usage = "%(prog)s [-f] hwNum"
    parser = argparse.ArgumentParser(usage=usage)
    parser.add_argument("hwNum", help="number of homework to submit")
    parser.add_argument("-f", "--force", action="store_true", dest="force",
                      help="force handin even with bad files")
    parser.add_argument("-s", "--skip", action="store_true",
                      help="hand in files without compiling")
    parser.add_argument("-n", "--dryrun", action="store_true", dest="dryrun",
                      help="run script without handing in")
    return parser.parse_args()

def doHandin(studentID, filesToSubmit):
    """Perform the handin tasks. Prints relevant errors on failures.

    Args:
        studentID (str): Student's Andrew ID.
        filesToSubmit (set): List of all files to be copied to the handin dir.

    Returns:
        (bool): True on success, False on failure.

    """
    if (DRY):
        return

    studentDir = HANDIN_DIR + "/" + HW_NUM + "/" + studentID
    # Check if student exists in handin directory
    if (not os.path.exists(studentDir)):
        raise utils.HandinDirError()
    goodPerms = utils.checkFs(studentID, studentDir)
    if (not goodPerms):
        raise utils.HandinPermError()

    for fileName in filesToSubmit:
        path = "./" + fileName
        # Since these files passed the check, they should exist, but just in case
        if (not os.path.exists(path)):
            continue
        shutil.copy(path, studentDir)

    timelogFile = open('{}/.handin_log'.format(studentDir), 'a')
    try:
        timeMsg = 'Handin performed at: '
        timeMsg += datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        timelogFile.write(timeMsg + '\n')
    except Exception:
        timelogFile.close()
        raise
    timelogFile.close()

def printHandinComplete():
    formatStr = "\nCode printout created as {}_code.pdf. Please check "
    formatStr += "that there are no errors in the PDF."
    print(formatStr.format(HW_NUM))
    print(bc.WARNING + "Please don't forget to submit this PDF to Gradescope!" + bc.ENDC)
    print(bc.WARNING + "Also don't forget your written homework!" + bc.ENDC)

def handinPrecheck(hasErrors, personalOutput):
    if (not hasErrors):
        return True

    attemptHandin = True
    utils.createErrLog(personalOutput)
    print("\n" + utils.warning("errors detected! Errors written to the file: errors.log.\n"))
    if (not FORCED):
        attemptHandin = False
        print("If you wish to submit an incomplete homework, then run the " +
        "handin script again with the '-f' flag.")
    else:
        print(utils.warning("you are attempting to submit homework with errors! " +
              "You will NOT receive any credit for files with errors.\n"))
        formatStr = "If this is intentional on your part, type '{}' and press Enter: "
        agreement = input(formatStr.format(HW_NUM))
        if (agreement != HW_NUM):
            attemptHandin = False
    return attemptHandin


################################################################################
#                           Code for the PDF script                            #
################################################################################

#Open my file, still using the "with" context manager goodness, but
# able to detect if the file isn't found (or other errors)
# See PEP 343 for more background
@contextmanager
def opened_with_error(filename, mode='r'):
    try:
        # [09/28/20]    Need to ignore encoding errors in case students submit
        #               non-unicode code...
        f = codecs.open(filename, mode, encoding='utf-8', errors='ignore')
    except IOError as err:
        yield None, err
    else:
        try:
            yield f, None
        finally:
            f.close

class ReportlabSyntaxHighlightingFormatter(Formatter):
    """A simple formatter for pygments that takes in the
    style representation, only extracts the color, and returns
    it as a json (because formatters can only return strings,
    so that we can use it in the reportlab code printing flow"""
    def __init__(self, **options):
        Formatter.__init__(self, **options)

    def format(self, tokensource, outfile):
        output = []
        for ttype, val in tokensource:
            while ttype not in self.style.styles:
                ttype = ttype.parent
            style = self.style.style_for_token(ttype)
            if style['color']:
                output.append({"val": val, "color": style['color']})
            else:
                output.append({"val": val, "color": ''})
        outfile.write(json.dumps(output))


class HW_Code_Maker:
    """ Make the HWX_code.pdf file for turnin on Gradescope.

    This class encapsulates the functionality to make the HWX_code.pdf
    file.  Such a file is a single PDF with each problem's file(s)
    pretty-printed.  Many problems do not require code, and so nothing
    will be included in this PDF file for those problems.  Some problems
    have a single file and a few have multiple files.

    The resulting PDF will have pages for each file, in order of the
    problem.

    To use, initialize the object with a homework dictionary describing
    the problems in that homework assignment.  Then, call the make_code
    method.
    """

    LINE_SPACING = 10  # points
    TOP_MARGIN   = .5 * inch # points
    LEFT_MARGIN  = .5 * inch # points
    BOTTOM_MARGIN = .5 * inch # points
    BOTTOM_OF_PAGE = 792 - BOTTOM_MARGIN

    def __init__(self, **kwargs):
        """ Initialize with a dictionary describing the HW problems.

        Keyword Arguments: (both are required)
        number : a string used as the homework number.  Typically 0-A
        problems : an ordered list of problem description dictionaries.
                   Exact format is defined in method print_file().
        """
        self.hw_number = kwargs['number']
        self.problems  = kwargs['problems']
        self.student   = kwargs['student']
        self.skipComp  = kwargs['skipComp']
        self.errList   = kwargs['errList']
        self.line_number = 1
        self.init_xy()
        self.canvas = None

    def init_xy(self):
        """ Set the x and y attributes to be the top of the page. """
        self.x = HW_Code_Maker.LEFT_MARGIN
        self.y = HW_Code_Maker.TOP_MARGIN

    def make_code(self):
        """ Make the PDF file with all homework code files printed. """
        filename = '{}_code.pdf'.format(self.hw_number)
        self.canvas = canvas.Canvas(filename,
                                    bottomup=0,
                                    pagesize=reportlab.lib.pagesizes.letter)
        # Need to add to the searchpath, so we can use a font that we specify
        reportlab.rl_config.TTFSearchPath.append(FONT_DIR)
        sFont = TTFont('SourceCodePro', 'SourceCodePro-Regular.ttf')
        pdfmetrics.registerFont(sFont)
        self.canvas.setFont('SourceCodePro', 10)

        count = 0

        for problem in self.problems:
            error = 0
            if ((self.errList[count] != None) or self.skipComp):
                error = 1
                self.report_problem_errors(problem, self.errList, count)
            if problem['files']:
                for filename in problem['files']:
                    self.page_number = 1
                    self.print_file(filename, problem, error)
            count += 1

        self.canvas.save()

    def draw_text_object(self, a_string, color_style=None):
        """ Draw a string onto the PDF page at the current position.

        Arguments:
        a_string : which will be printed, either a str or a list of str | {"val": str, "color": str}
        color_style : one of 'None', 'Header', 'Warning'
                      Indicates the string should be black, green or red.

        Returns: Nothing

        Note: The y attribute is updated such that the next string to be
              printed will be on a following line.
        """
        # no syntax highlighting or highlighting does not match the string
        # or its a warning or something
        text_object = self.canvas.beginText()
        text_object.setTextOrigin(self.x, self.y)
        merged_line = "" # just raw text
        line_highlighted = [] # list of dictionaries with all colors
        if isinstance(a_string, str):
            merged_line = a_string.rstrip()
            line_highlighted = [{"val": merged_line, "color": ''}]
        elif isinstance(a_string, list):
            merged_line = ""
            for item in a_string:
                if isinstance(item, str):
                    merged_line += item
                    line_highlighted.append({"val": item, "color": ''})
                elif isinstance(item, dict):
                    merged_line += item["val"]
                    line_highlighted.append(item)
                else:
                    raise Exception("Invalid type in a_string: {}".format(type(item)))
        else:
            raise Exception("Invalid type in a_string: {}".format(type(a_string)))
        for line_snippet in line_highlighted:
            text_object.setFont('SourceCodePro', 10)
            if color_style == 'Header':
                text_object.setFillColor(colors.green)
            elif color_style == 'Warning':
                text_object.setFillColor(colors.red)
            elif color_style == 'Report':
                text_object.setFillColor(colors.blue)
            else:
                if line_snippet["color"] == '':
                    text_object.setFillColor(colors.dimgrey)
                else:
                    text_object.setFillColor(colors.HexColor("#" + line_snippet["color"]))
            text_object.textOut(text=line_snippet["val"].replace('\n', '').replace('\r', '').replace('\t', '  '))
        self.canvas.drawText(text_object)
        self.y += HW_Code_Maker.LINE_SPACING

    def report_problem_errors(self, prob_dict, errList, count):
        """ If there are errors for the problem, we print all errors on the
            first page

            Header will contain problem name and andrewID
            The rest of the page will contain the compilation errors from
            terminal
        """
        self.init_xy()
        prob_number = prob_dict['number']
        prob_drill  = prob_dict['drill']
        prob_points = prob_dict['points']
        if (prob_number < 0):   # To be used for lab code
            to_print = 'Lab Code [{} points]'.format(prob_points)
        else:
            to_print = 'Problem {}: [{} points]'.format(prob_number, prob_points)
        if prob_drill:
            to_print = to_print + ' Drill problem'
        if (self.skipComp):
            # Blue for skipped compilation
            self.draw_text_object(to_print, 'Report')
        else:
            # Red for error
            self.draw_text_object(to_print, 'Warning')
        to_print = 'AndrewID: {}'.format(self.student)
        self.draw_text_object(to_print, 'Header')

        self.y += HW_Code_Maker.LINE_SPACING # include a blank line

        if (self.skipComp):
            # If compilation was skipped, report so
            to_print = 'Note: Compilation for this submission was skipped'
            self.draw_text_object(to_print, color_style='None')
        else:
            # Else, we know there are errors
            # Read error line by line
            errLines = errList[count].splitlines()

            to_print = 'Compilation Errors:'
            self.draw_text_object(to_print, color_style='Warning')
            self.y += HW_Code_Maker.LINE_SPACING # include a blank line

            for line in errLines:
                if self.y > HW_Code_Maker.BOTTOM_OF_PAGE:
                    #reset page if page is full
                    self.init_xy()
                    self.canvas.showPage()
                    if (prob_number < 0):   # To be used for lab code
                        to_print = 'Lab Code [{} points]'.format(prob_points)
                    else:
                        to_print = 'Problem {}: [{} points]'.format(prob_number, prob_points)
                    if prob_drill:
                        to_print = to_print + ' Drill problem'
                    if (self.skipComp):
                        # Blue for skipped compilation
                        self.draw_text_object(to_print, 'Report')
                    else:
                        # Red for error
                        self.draw_text_object(to_print, 'Warning')
                    self.y += HW_Code_Maker.LINE_SPACING # include a blank line

                #purge ansi color codes from terminal output
                ansi_escape = re.compile(r'\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])')
                line = ansi_escape.sub('', line)

                #search if this line references file directory
                if "/afs/" in line:
                    # we anonymize file directory
                    line = "  \".../" + line.rsplit('/', 1)[1]

                to_print = line
                self.draw_text_object(to_print, color_style='None')

        self.canvas.showPage()

    def draw_header(self, a_filename, prob_dict, error):
        """ Draw the header at the top of each page.

        The header is one or two lines at the top of each page in the PDF.
        Printed in Green, the header contains information about the problem,
        point values, drill status and filename.
        If the file has taken more than one page, the following headers
        will include a page number.

        Arguments:
        a_filename : the filename of the file being printed.  Note that this
                     is necessary outside of the prob_dict, as there could
                     be multiple files in the problem and we want to know
                     which is currently printing.
        prob_dict : the dictionary describing the problem.  Full documentation
                    of this dictionary is in the print_file method.

        Returns: Nothing
        """
        self.init_xy()
        prob_number = prob_dict['number']
        prob_drill  = prob_dict['drill']
        prob_points = prob_dict['points']
        if self.page_number == 1:
            if (prob_number < 0):   # To be used for lab code
                to_print = 'Lab Code [{} points]'.format(prob_points)
            else:
                to_print = 'Problem {}: [{} points]'.format(prob_number, prob_points)
            if prob_drill:
                to_print = to_print + ' Drill problem'
            if (self.skipComp):
                self.draw_text_object(to_print, 'Report')
            elif (error):
                self.draw_text_object(to_print, 'Warning')
            else:
                self.draw_text_object(to_print, 'Header')
            to_print = 'Filename: {}'.format(a_filename)
            self.draw_text_object(to_print, 'Header')
            # Removed line to preserve anonymity for grading
            # Uncomment if you want to print out student ID as well
            to_print = 'AndrewID: {}'.format(self.student)
            self.draw_text_object(to_print, 'Header')
        else:
            self.canvas.showPage()
            filename_length = len(a_filename)
            middle_length = 84 - 12 - filename_length - 1
            format_string = 'Filename: {{}} {{:>{}}} {{}}'.format(middle_length)
            to_print = format_string.format(a_filename, 'Page #:', self.page_number)
            if (self.skipComp):
                self.draw_text_object(to_print, 'Report')
            elif (error):
                self.draw_text_object(to_print, 'Warning')
            else:
                self.draw_text_object(to_print, 'Header')
        self.y += HW_Code_Maker.LINE_SPACING # include a blank line
        self.page_number += 1


    def _split_highlighted_tokens(self, tokens):
        """Split a list of syntax highlighted tokens into a
        list of lists, where each list is a line of tokens."""
        cur_line = []
        for token in tokens:
            if "\n" in token["val"]:
                splits = token["val"].split("\n")
                for split in splits[:-1]:
                    if split:
                        cur_line.append({"val": split, "color": token["color"]})
                    yield cur_line
                    cur_line = []
                if splits[-1]:
                    cur_line.append({"val": splits[-1], "color": token["color"]})
            else:
                cur_line.append(token)
        if len(cur_line) > 0:
            yield cur_line


    def print_file(self, a_filename, prob_dict, error):
        """ Print a single file into the PDF on one or more pages.

        Each file is 'pretty-printed' in a fixed-width font, with line numbers
        added at the left side.  Note that the line numbers are assumed to
        never be greater than two digits.

        As each line is printed, it is checked for two errors (currently).
        If the line has one or more errors, then it will be printed in Red:
        1) Are there any tab characters on the line.  If so, the tabs are
           replaced by double spaces and an error message is printed after
           the line.
        2) Is the line (with tabs replaced) longer than 80 characters?  If
           so, the first 77 characters of the line are printed, followed
           by three periods ('...').  An error message is then printed which
           specifies how many characters are in the full line.
        Note: a single line could have both errors.

        If the file does not exist, then a red error message is printed
        which states so.

        Arguments:
        a_filename : the filename of the file being printed.  Note that this
                     is necessary outside of the prob_dict, as there could
                     be multiple files in the problem and we want to know
                     which is currently printing.
        prob_dict : a dictionary describing the current homework problem.

        Returns : Nothing

        The dictionary contains the following required keys:
        number : A string with the number of the homework assignment.
        drill : A boolean.  True if this problem is a drill problem.
                            False otherwise.
        points : An integer specifying the number of points for the problem.
        files : A list of filenames required for the problem.  Each element
                in the list is a string.  The elements should be ordered as
                the files should be printed.
                If the problem does not require any files, then this value
                should be a None (i.e. a NoneType)
        """
        self.line_number = 1
        self.draw_header(a_filename, prob_dict, error)

        try:
            lexer = get_lexer_for_filename(a_filename, stripnl=False)
        except:
            lexer = TextLexer(stripnl=False)


        with opened_with_error(a_filename) as (f_in, err):
            if err:
                line = 'File {} was not found'.format(a_filename)
                self.draw_text_object(line, color_style='Warning')
            else:
                try:
                    syntax_highlighted = highlight(f_in.read(), lexer, ReportlabSyntaxHighlightingFormatter(style='xcode'))
                    line_highlighted = json.loads(syntax_highlighted)
                except:
                    line_highlighted = [{"val": f_in.read(), "color": ''}]
                for line in self._split_highlighted_tokens(line_highlighted):
                    joined_line = ''.join([token['val'] for token in line])
                    if self.y > HW_Code_Maker.BOTTOM_OF_PAGE:
                        self.draw_header(a_filename, prob_dict, error)
                    contains_tabs = False
                    color_style = 'None'
                    if '\t' in joined_line:
                        contains_tabs = True
                        # We replace tabs in the draw_output function
                        color_style = 'Warning'
                    # line = line.rstrip()
                    line_length = len(joined_line)
                    if line_length > 80:
                        to_print = '{:3d} {}...'.format(self.line_number, joined_line[:77]) #truncates to 80 characters.  Ironic comment
                        self.draw_text_object(to_print, 'Warning')
                        to_print = 'Line length of {} (max is 80)'.format(line_length)
                        self.draw_text_object(to_print, 'Warning')
                    else:
                        to_print = ['{:3d} '.format(self.line_number)] + line
                        self.draw_text_object(to_print, color_style)

                    if contains_tabs:
                        self.draw_text_object('Line contains tabs' +
                               ' (each tab replaced by 2 spaces in this print)',
                               color_style)
                    self.line_number += 1

        self.canvas.showPage()

def makePDF(student, problemDictList, skipComp, errList):
    cfgPath = CFG_DIR + "/" + HW_NUM + "_cfg.json"
    # TODO: make this more graceful
    for prob in problemDictList:
        tempFiles = set()
        if (prob["files"] != None):
            for f in prob["files"]:
                if ("*" in f):
                    toSkip = False
                    for bad in NO_PRINT:
                        if (bad in f):
                            toSkip = True
                    if (toSkip):
                        continue
                    allFiles = set(glob.glob(f))
                    tempFiles = tempFiles.union(allFiles)
                else:
                    tempFiles.add(f)
        prob["files"] = sorted(list(tempFiles))

    hw_dict = {'number' : HW_NUM, 'problems' : problemDictList,
               'student' : student, 'skipComp' : skipComp, 'errList' : errList}

    maker = HW_Code_Maker(**hw_dict)
    maker.make_code()

def main():
    args = getArgs()

    # Save relevant fields
    global FORCED
    FORCED = args.force
    global SKIP_COMP
    SKIP_COMP = args.skip
    global HW_NUM
    HW_NUM = args.hwNum.lower()     # Make case insensitive
    global DRY
    DRY = args.dryrun

    # Initialize variables
    selfID = os.getlogin().lower()  # Get student's Andrew ID

    try:
        # Parse config file and do relevant operations
        cfgPath = utils.searchCfg(HW_NUM, CFG_DIR)
        # Take the proper (case-sensitive) HW_NUM
        HW_NUM = cfgPath[cfgPath.rindex("/")+1:cfgPath.index("_cfg.json")]
        config = utils.parseConfig(CFG_DIR + "/" + HW_NUM + "_cfg.json")
        opArray = utils.makeOpArray(config, refFilePath=REFFILE_DIR,
                skipCompile=SKIP_COMP)
        if (SKIP_COMP):
            skip_warning = "you are choosing to skip compilation checks. Note that "
            skip_warning += "code that doesn't compile WILL get ZERO credit."
            print(utils.warning(skip_warning))
        (filesToSubmit, hasAnyErrors, errString, errList) = utils.doOpArray(opArray)
        personalOutput = utils.getOutputHeader(selfID, HW_NUM)
        personalOutput += errString
    except (KeyboardInterrupt, SystemExit):
        raise
    except (utils.Handin240Error) as e:
        print(e)
        return e.errno
    except Exception as e:
        print("Encountered unknown error: {}".format(e))
        traceback.print_exc()
        return utils.ERR_UNKNOWN

    # Result strings WITH COLORS \o/
    handinCreated = bc.OKGREEN + "Handin complete." + bc.ENDC
    handinNotCreated = bc.FAIL + "Handin not complete." + bc.ENDC

    # Check if handin had any errors
    attemptHandin = handinPrecheck(hasAnyErrors, personalOutput)

    if (attemptHandin):
        try:
            doHandin(selfID, filesToSubmit)
            if (DRY):
                print("\nDryrun '-n' flag specified. Handin was not done")
                print(handinNotCreated)
                status = utils.HANDIN_NO
            else:
                print("\n" + handinCreated)
                status = utils.HANDIN_YES
            # Create output PDF
            makePDF(selfID, config, SKIP_COMP, errList)
            printHandinComplete()
            return status
        except (KeyboardInterrupt, SystemExit):
            raise
        except (utils.Handin240Error) as e:
            print(e)
            print("\n" + handinNotCreated)
            return utils.HANDIN_NO
        except Exception as e:
            print("Encountered unknown error: {}".format(e))
            traceback.print_exc()
            return utils.ERR_UNKNOWN
    else:
        print("\n" + handinNotCreated)
        return utils.HANDIN_NO

sys.exit(main())
